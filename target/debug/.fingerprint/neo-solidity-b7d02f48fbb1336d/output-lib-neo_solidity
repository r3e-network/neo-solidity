{"$message_type":"diagnostic","message":"stripping a prefix manually","code":{"code":"clippy::manual_strip","explanation":null},"level":"error","spans":[{"file_name":"src/codegen.rs","byte_start":8483,"byte_end":8494,"line_start":237,"line_end":237,"column_start":37,"column_end":48,"is_primary":true,"text":[{"text":"                        hex::decode(&value[2..]).unwrap_or_else(|_| value.as_bytes().to_vec())","highlight_start":37,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the prefix was tested here","code":null,"level":"note","spans":[{"file_name":"src/codegen.rs","byte_start":8418,"byte_end":8445,"line_start":236,"line_end":236,"column_start":32,"column_end":59,"is_primary":true,"text":[{"text":"                    let data = if value.starts_with(\"0x\") {","highlight_start":32,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`-D clippy::manual-strip` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(clippy::manual_strip)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"try using the `strip_prefix` method","code":null,"level":"help","spans":[{"file_name":"src/codegen.rs","byte_start":8418,"byte_end":8445,"line_start":236,"line_end":236,"column_start":32,"column_end":59,"is_primary":true,"text":[{"text":"                    let data = if value.starts_with(\"0x\") {","highlight_start":32,"highlight_end":59}],"label":null,"suggested_replacement":"if let Some(<stripped>) = value.strip_prefix(\"0x\") ","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/codegen.rs","byte_start":8483,"byte_end":8494,"line_start":237,"line_end":237,"column_start":37,"column_end":48,"is_primary":true,"text":[{"text":"                        hex::decode(&value[2..]).unwrap_or_else(|_| value.as_bytes().to_vec())","highlight_start":37,"highlight_end":48}],"label":null,"suggested_replacement":"<stripped>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: stripping a prefix manually\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:237:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        hex::decode(&value[2..]).unwrap_or_else(|_| value.as_bytes().to_vec())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the prefix was tested here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:236:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let data = if value.starts_with(\"0x\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `-D clippy::manual-strip` implied by `-D warnings`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(clippy::manual_strip)]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using the `strip_prefix` method\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                    let data = \u001b[0m\u001b[0m\u001b[38;5;10mif let Some(<stripped>) = value.strip_prefix(\"0x\") \u001b[0m\u001b[0m{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                        hex::decode(\u001b[0m\u001b[0m\u001b[38;5;10m<stripped>\u001b[0m\u001b[0m).unwrap_or_else(|_| value.as_bytes().to_vec())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"parameter is only used in recursion","code":{"code":"clippy::only_used_in_recursion","explanation":null},"level":"error","spans":[{"file_name":"src/codegen.rs","byte_start":3928,"byte_end":3932,"line_start":130,"line_end":130,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"        &mut self,","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"parameter used here","code":null,"level":"note","spans":[{"file_name":"src/codegen.rs","byte_start":4312,"byte_end":4316,"line_start":140,"line_end":140,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.generate_node(stmt, bytecode, functions, events, estimated_gas)?;","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":4869,"byte_end":4873,"line_start":157,"line_end":157,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.generate_node(body, bytecode, functions, events, estimated_gas)?;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":5140,"byte_end":5144,"line_start":163,"line_end":163,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.generate_node(value, bytecode, functions, events, estimated_gas)?;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":5825,"byte_end":5829,"line_start":178,"line_end":178,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.generate_node(arg, bytecode, functions, events, estimated_gas)?;","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":9392,"byte_end":9396,"line_start":263,"line_end":263,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.generate_node(condition, bytecode, functions, events, estimated_gas)?;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":9735,"byte_end":9739,"line_start":271,"line_end":271,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.generate_node(then_branch, bytecode, functions, events, estimated_gas)?;","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":10316,"byte_end":10320,"line_start":284,"line_end":284,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"                        self.generate_node(else_stmt, bytecode, functions, events, estimated_gas)?;","highlight_start":25,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`-D clippy::only-used-in-recursion` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(clippy::only_used_in_recursion)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: parameter is only used in recursion\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:130:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        &mut self,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: parameter used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:140:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.generate_node(stmt, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(body, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m163\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(value, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.generate_node(arg, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(condition, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(then_branch, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        self.generate_node(else_stmt, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `-D clippy::only-used-in-recursion` implied by `-D warnings`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(clippy::only_used_in_recursion)]`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"parameter is only used in recursion","code":{"code":"clippy::only_used_in_recursion","explanation":null},"level":"error","spans":[{"file_name":"src/codegen.rs","byte_start":4035,"byte_end":4041,"line_start":134,"line_end":134,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        events: &mut Vec<String>,","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"parameter used here","code":null,"level":"note","spans":[{"file_name":"src/codegen.rs","byte_start":4358,"byte_end":4364,"line_start":140,"line_end":140,"column_start":67,"column_end":73,"is_primary":true,"text":[{"text":"                    self.generate_node(stmt, bytecode, functions, events, estimated_gas)?;","highlight_start":67,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":4915,"byte_end":4921,"line_start":157,"line_end":157,"column_start":63,"column_end":69,"is_primary":true,"text":[{"text":"                self.generate_node(body, bytecode, functions, events, estimated_gas)?;","highlight_start":63,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":5187,"byte_end":5193,"line_start":163,"line_end":163,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                self.generate_node(value, bytecode, functions, events, estimated_gas)?;","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":5870,"byte_end":5876,"line_start":178,"line_end":178,"column_start":66,"column_end":72,"is_primary":true,"text":[{"text":"                    self.generate_node(arg, bytecode, functions, events, estimated_gas)?;","highlight_start":66,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":9443,"byte_end":9449,"line_start":263,"line_end":263,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"                self.generate_node(condition, bytecode, functions, events, estimated_gas)?;","highlight_start":68,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":9788,"byte_end":9794,"line_start":271,"line_end":271,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"                self.generate_node(then_branch, bytecode, functions, events, estimated_gas)?;","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":10367,"byte_end":10373,"line_start":284,"line_end":284,"column_start":76,"column_end":82,"is_primary":true,"text":[{"text":"                        self.generate_node(else_stmt, bytecode, functions, events, estimated_gas)?;","highlight_start":76,"highlight_end":82}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/codegen.rs","byte_start":4035,"byte_end":4041,"line_start":134,"line_end":134,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        events: &mut Vec<String>,","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":"_events","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: parameter is only used in recursion\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:134:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m134\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        events: &mut Vec<String>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: if this is intentional, prefix it with an underscore: `_events`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: parameter used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:140:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.generate_node(stmt, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(body, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m163\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(value, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.generate_node(arg, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m263\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(condition, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m271\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.generate_node(then_branch, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        self.generate_node(else_stmt, bytecode, functions, events, estimated_gas)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"parameter is only used in recursion","code":{"code":"clippy::only_used_in_recursion","explanation":null},"level":"error","spans":[{"file_name":"src/codegen.rs","byte_start":13234,"byte_end":13238,"line_start":378,"line_end":378,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"    fn visit_ast_for_source_map(&self, node: &AstNode, source_map: &mut String, offset: usize) {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"parameter used here","code":null,"level":"note","spans":[{"file_name":"src/codegen.rs","byte_start":13685,"byte_end":13689,"line_start":389,"line_end":389,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_ast_for_source_map(stmt, source_map, offset + 10);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: parameter is only used in recursion\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:378:34\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn visit_ast_for_source_map(&self, node: &AstNode, source_map: &mut String, offset: usize) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: parameter used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:389:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m389\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_ast_for_source_map(stmt, source_map, offset + 10);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"parameter is only used in recursion","code":{"code":"clippy::only_used_in_recursion","explanation":null},"level":"error","spans":[{"file_name":"src/codegen.rs","byte_start":13840,"byte_end":13844,"line_start":396,"line_end":396,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"    fn count_ast_nodes(&self, node: &AstNode) -> usize {","highlight_start":25,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"parameter used here","code":null,"level":"note","spans":[{"file_name":"src/codegen.rs","byte_start":14091,"byte_end":14095,"line_start":402,"line_end":402,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"                    count += self.count_ast_nodes(stmt);","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":14228,"byte_end":14232,"line_start":406,"line_end":406,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"                count += self.count_ast_nodes(body);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":14429,"byte_end":14433,"line_start":413,"line_end":413,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"                count += self.count_ast_nodes(condition);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":14487,"byte_end":14491,"line_start":414,"line_end":414,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"                count += self.count_ast_nodes(then_branch);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/codegen.rs","byte_start":14606,"byte_end":14610,"line_start":416,"line_end":416,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"                    count += self.count_ast_nodes(else_stmt);","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: parameter is only used in recursion\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:396:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m396\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn count_ast_nodes(&self, node: &AstNode) -> usize {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: parameter used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/codegen.rs:402:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m402\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    count += self.count_ast_nodes(stmt);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count += self.count_ast_nodes(body);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m413\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count += self.count_ast_nodes(condition);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m414\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                count += self.count_ast_nodes(then_branch);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Some(else_stmt) = else_branch {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m416\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    count += self.count_ast_nodes(else_stmt);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"returning the result of a `let` binding from a block","code":{"code":"clippy::let_and_return","explanation":null},"level":"error","spans":[{"file_name":"src/optimizer.rs","byte_start":1674,"byte_end":3979,"line_start":61,"line_end":119,"column_start":9,"column_end":11,"is_primary":false,"text":[{"text":"        let optimized_node = match node.node_type {","highlight_start":9,"highlight_end":52},{"text":"            AstNodeType::FunctionCall { name, arguments } => {","highlight_start":1,"highlight_end":63},{"text":"                // Fold constant arithmetic operations","highlight_start":1,"highlight_end":55},{"text":"                if let Some(result) = self.evaluate_constant_expression(&name, &arguments) {","highlight_start":1,"highlight_end":93},{"text":"                    self.stats.folded_constants += 1;","highlight_start":1,"highlight_end":54},{"text":"                    AstNode {","highlight_start":1,"highlight_end":30},{"text":"                        node_type: AstNodeType::Literal {","highlight_start":1,"highlight_end":58},{"text":"                            value: result.to_string(),","highlight_start":1,"highlight_end":55},{"text":"                        },","highlight_start":1,"highlight_end":27},{"text":"                        line: node.line,","highlight_start":1,"highlight_end":41},{"text":"                        column: node.column,","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // Recursively optimize arguments","highlight_start":1,"highlight_end":54},{"text":"                    let optimized_args = arguments","highlight_start":1,"highlight_end":51},{"text":"                        .into_iter()","highlight_start":1,"highlight_end":37},{"text":"                        .map(|arg| self.fold_constants_recursive(arg))","highlight_start":1,"highlight_end":71},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    AstNode {","highlight_start":1,"highlight_end":30},{"text":"                        node_type: AstNodeType::FunctionCall {","highlight_start":1,"highlight_end":63},{"text":"                            name,","highlight_start":1,"highlight_end":34},{"text":"                            arguments: optimized_args,","highlight_start":1,"highlight_end":55},{"text":"                        },","highlight_start":1,"highlight_end":27},{"text":"                        line: node.line,","highlight_start":1,"highlight_end":41},{"text":"                        column: node.column,","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            AstNodeType::Object { statements } => {","highlight_start":1,"highlight_end":52},{"text":"                let optimized_statements = statements","highlight_start":1,"highlight_end":54},{"text":"                    .into_iter()","highlight_start":1,"highlight_end":33},{"text":"                    .map(|stmt| self.fold_constants_recursive(stmt))","highlight_start":1,"highlight_end":69},{"text":"                    .collect();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                AstNode {","highlight_start":1,"highlight_end":26},{"text":"                    node_type: AstNodeType::Object {","highlight_start":1,"highlight_end":53},{"text":"                        statements: optimized_statements,","highlight_start":1,"highlight_end":58},{"text":"                    },","highlight_start":1,"highlight_end":23},{"text":"                    line: node.line,","highlight_start":1,"highlight_end":37},{"text":"                    column: node.column,","highlight_start":1,"highlight_end":41},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            AstNodeType::Block { statements } => {","highlight_start":1,"highlight_end":51},{"text":"                let optimized_statements = statements","highlight_start":1,"highlight_end":54},{"text":"                    .into_iter()","highlight_start":1,"highlight_end":33},{"text":"                    .map(|stmt| self.fold_constants_recursive(stmt))","highlight_start":1,"highlight_end":69},{"text":"                    .collect();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                AstNode {","highlight_start":1,"highlight_end":26},{"text":"                    node_type: AstNodeType::Block {","highlight_start":1,"highlight_end":52},{"text":"                        statements: optimized_statements,","highlight_start":1,"highlight_end":58},{"text":"                    },","highlight_start":1,"highlight_end":23},{"text":"                    line: node.line,","highlight_start":1,"highlight_end":37},{"text":"                    column: node.column,","highlight_start":1,"highlight_end":41},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            _ => node, // Return unchanged for other node types","highlight_start":1,"highlight_end":64},{"text":"        };","highlight_start":1,"highlight_end":11}],"label":"unnecessary `let` binding","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/optimizer.rs","byte_start":3989,"byte_end":4003,"line_start":121,"line_end":121,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        optimized_node","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`-D clippy::let-and-return` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(clippy::let_and_return)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"return the expression directly","code":null,"level":"help","spans":[{"file_name":"src/optimizer.rs","byte_start":1674,"byte_end":3979,"line_start":61,"line_end":119,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        let optimized_node = match node.node_type {","highlight_start":9,"highlight_end":52},{"text":"            AstNodeType::FunctionCall { name, arguments } => {","highlight_start":1,"highlight_end":63},{"text":"                // Fold constant arithmetic operations","highlight_start":1,"highlight_end":55},{"text":"                if let Some(result) = self.evaluate_constant_expression(&name, &arguments) {","highlight_start":1,"highlight_end":93},{"text":"                    self.stats.folded_constants += 1;","highlight_start":1,"highlight_end":54},{"text":"                    AstNode {","highlight_start":1,"highlight_end":30},{"text":"                        node_type: AstNodeType::Literal {","highlight_start":1,"highlight_end":58},{"text":"                            value: result.to_string(),","highlight_start":1,"highlight_end":55},{"text":"                        },","highlight_start":1,"highlight_end":27},{"text":"                        line: node.line,","highlight_start":1,"highlight_end":41},{"text":"                        column: node.column,","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    // Recursively optimize arguments","highlight_start":1,"highlight_end":54},{"text":"                    let optimized_args = arguments","highlight_start":1,"highlight_end":51},{"text":"                        .into_iter()","highlight_start":1,"highlight_end":37},{"text":"                        .map(|arg| self.fold_constants_recursive(arg))","highlight_start":1,"highlight_end":71},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    AstNode {","highlight_start":1,"highlight_end":30},{"text":"                        node_type: AstNodeType::FunctionCall {","highlight_start":1,"highlight_end":63},{"text":"                            name,","highlight_start":1,"highlight_end":34},{"text":"                            arguments: optimized_args,","highlight_start":1,"highlight_end":55},{"text":"                        },","highlight_start":1,"highlight_end":27},{"text":"                        line: node.line,","highlight_start":1,"highlight_end":41},{"text":"                        column: node.column,","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            AstNodeType::Object { statements } => {","highlight_start":1,"highlight_end":52},{"text":"                let optimized_statements = statements","highlight_start":1,"highlight_end":54},{"text":"                    .into_iter()","highlight_start":1,"highlight_end":33},{"text":"                    .map(|stmt| self.fold_constants_recursive(stmt))","highlight_start":1,"highlight_end":69},{"text":"                    .collect();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                AstNode {","highlight_start":1,"highlight_end":26},{"text":"                    node_type: AstNodeType::Object {","highlight_start":1,"highlight_end":53},{"text":"                        statements: optimized_statements,","highlight_start":1,"highlight_end":58},{"text":"                    },","highlight_start":1,"highlight_end":23},{"text":"                    line: node.line,","highlight_start":1,"highlight_end":37},{"text":"                    column: node.column,","highlight_start":1,"highlight_end":41},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            AstNodeType::Block { statements } => {","highlight_start":1,"highlight_end":51},{"text":"                let optimized_statements = statements","highlight_start":1,"highlight_end":54},{"text":"                    .into_iter()","highlight_start":1,"highlight_end":33},{"text":"                    .map(|stmt| self.fold_constants_recursive(stmt))","highlight_start":1,"highlight_end":69},{"text":"                    .collect();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                AstNode {","highlight_start":1,"highlight_end":26},{"text":"                    node_type: AstNodeType::Block {","highlight_start":1,"highlight_end":52},{"text":"                        statements: optimized_statements,","highlight_start":1,"highlight_end":58},{"text":"                    },","highlight_start":1,"highlight_end":23},{"text":"                    line: node.line,","highlight_start":1,"highlight_end":37},{"text":"                    column: node.column,","highlight_start":1,"highlight_end":41},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            _ => node, // Return unchanged for other node types","highlight_start":1,"highlight_end":64},{"text":"        };","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/optimizer.rs","byte_start":3989,"byte_end":4003,"line_start":121,"line_end":121,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        optimized_node","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":"match node.node_type {\n            AstNodeType::FunctionCall { name, arguments } => {\n                // Fold constant arithmetic operations\n                if let Some(result) = self.evaluate_constant_expression(&name, &arguments) {\n                    self.stats.folded_constants += 1;\n                    AstNode {\n                        node_type: AstNodeType::Literal {\n                            value: result.to_string(),\n                        },\n                        line: node.line,\n                        column: node.column,\n                    }\n                } else {\n                    // Recursively optimize arguments\n                    let optimized_args = arguments\n                        .into_iter()\n                        .map(|arg| self.fold_constants_recursive(arg))\n                        .collect();\n\n                    AstNode {\n                        node_type: AstNodeType::FunctionCall {\n                            name,\n                            arguments: optimized_args,\n                        },\n                        line: node.line,\n                        column: node.column,\n                    }\n                }\n            }\n            AstNodeType::Object { statements } => {\n                let optimized_statements = statements\n                    .into_iter()\n                    .map(|stmt| self.fold_constants_recursive(stmt))\n                    .collect();\n\n                AstNode {\n                    node_type: AstNodeType::Object {\n                        statements: optimized_statements,\n                    },\n                    line: node.line,\n                    column: node.column,\n                }\n            }\n            AstNodeType::Block { statements } => {\n                let optimized_statements = statements\n                    .into_iter()\n                    .map(|stmt| self.fold_constants_recursive(stmt))\n                    .collect();\n\n                AstNode {\n                    node_type: AstNodeType::Block {\n                        statements: optimized_statements,\n                    },\n                    line: node.line,\n                    column: node.column,\n                }\n            }\n            _ => node, // Return unchanged for other node types\n        }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: returning the result of a `let` binding from a block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/optimizer.rs:121:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let optimized_node = match node.node_type {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            AstNodeType::FunctionCall { name, arguments } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                // Fold constant arithmetic operations\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Some(result) = self.evaluate_constant_expression(&name, &arguments) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            _ => node, // Return unchanged for other node types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munnecessary `let` binding\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        optimized_node\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `-D clippy::let-and-return` implied by `-D warnings`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(clippy::let_and_return)]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: return the expression directly\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mmatch node.node_type {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+             AstNodeType::FunctionCall { name, arguments } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 // Fold constant arithmetic operations\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 if let Some(result) = self.evaluate_constant_expression(&name, &arguments) {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     self.stats.folded_constants += 1;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     AstNode {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         node_type: AstNodeType::Literal {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             value: result.to_string(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         },\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         line: node.line,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         column: node.column,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 } else {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     // Recursively optimize arguments\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     let optimized_args = arguments\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         .map(|arg| self.fold_constants_recursive(arg))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m80\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         .collect();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m81\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     AstNode {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         node_type: AstNodeType::FunctionCall {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             name,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                             arguments: optimized_args,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         },\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         line: node.line,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                         column: node.column,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+             AstNodeType::Object { statements } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 let optimized_statements = statements\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     .map(|stmt| self.fold_constants_recursive(stmt))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m96\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     .collect();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                 AstNode {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+                     node_type: AstNodeType::Object {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         statements: optimized_statements,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     },\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     line: node.line,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     column: node.column,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             AstNodeType::Block { statements } => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m107\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 let optimized_statements = statements\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     .into_iter()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     .map(|stmt| self.fold_constants_recursive(stmt))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     .collect();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 AstNode {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     node_type: AstNodeType::Block {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                         statements: optimized_statements,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m115\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     },\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m116\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     line: node.line,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                     column: node.column,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m118\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             _ => node, // Return unchanged for other node types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"stripping a prefix manually","code":{"code":"clippy::manual_strip","explanation":null},"level":"error","spans":[{"file_name":"src/optimizer.rs","byte_start":5120,"byte_end":5131,"line_start":151,"line_end":151,"column_start":37,"column_end":48,"is_primary":true,"text":[{"text":"                u64::from_str_radix(&value[2..], 16).ok()","highlight_start":37,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the prefix was tested here","code":null,"level":"note","spans":[{"file_name":"src/optimizer.rs","byte_start":5055,"byte_end":5082,"line_start":150,"line_end":150,"column_start":13,"column_end":40,"is_primary":true,"text":[{"text":"            if value.starts_with(\"0x\") {","highlight_start":13,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"try using the `strip_prefix` method","code":null,"level":"help","spans":[{"file_name":"src/optimizer.rs","byte_start":5055,"byte_end":5082,"line_start":150,"line_end":150,"column_start":13,"column_end":40,"is_primary":true,"text":[{"text":"            if value.starts_with(\"0x\") {","highlight_start":13,"highlight_end":40}],"label":null,"suggested_replacement":"if let Some(<stripped>) = value.strip_prefix(\"0x\") ","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/optimizer.rs","byte_start":5120,"byte_end":5131,"line_start":151,"line_end":151,"column_start":37,"column_end":48,"is_primary":true,"text":[{"text":"                u64::from_str_radix(&value[2..], 16).ok()","highlight_start":37,"highlight_end":48}],"label":null,"suggested_replacement":"<stripped>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: stripping a prefix manually\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/optimizer.rs:151:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                u64::from_str_radix(&value[2..], 16).ok()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the prefix was tested here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/optimizer.rs:150:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            if value.starts_with(\"0x\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try using the `strip_prefix` method\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mif let Some(<stripped>) = value.strip_prefix(\"0x\") \u001b[0m\u001b[0m{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m                u64::from_str_radix(\u001b[0m\u001b[0m\u001b[38;5;10m<stripped>\u001b[0m\u001b[0m, 16).ok()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"you should consider adding a `Default` implementation for `SemanticAnalyzer`","code":{"code":"clippy::new_without_default","explanation":null},"level":"error","spans":[{"file_name":"src/semantic.rs","byte_start":833,"byte_end":874,"line_start":41,"line_end":43,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    pub fn new() -> Self {","highlight_start":5,"highlight_end":27},{"text":"        Self","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`-D clippy::new-without-default` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(clippy::new_without_default)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"try adding this","code":null,"level":"help","spans":[{"file_name":"src/semantic.rs","byte_start":805,"byte_end":805,"line_start":40,"line_end":40,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"impl SemanticAnalyzer {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"impl Default for SemanticAnalyzer {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: you should consider adding a `Default` implementation for `SemanticAnalyzer`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/semantic.rs:41:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `-D clippy::new-without-default` implied by `-D warnings`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: to override `-D warnings` add `#[allow(clippy::new_without_default)]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try adding this\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ impl Default for SemanticAnalyzer {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+     fn default() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+         Self::new()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+     }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"parameter is only used in recursion","code":{"code":"clippy::only_used_in_recursion","explanation":null},"level":"error","spans":[{"file_name":"src/semantic.rs","byte_start":8353,"byte_end":8357,"line_start":246,"line_end":246,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"    fn visit_node_recursive<F>(&self, node: &AstNode, visitor: &mut F, depth: u32)","highlight_start":33,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"parameter used here","code":null,"level":"note","spans":[{"file_name":"src/semantic.rs","byte_start":8665,"byte_end":8669,"line_start":255,"line_end":255,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(stmt, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":8818,"byte_end":8822,"line_start":259,"line_end":259,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(body, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9035,"byte_end":9039,"line_start":266,"line_end":266,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(condition, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9109,"byte_end":9113,"line_start":267,"line_end":267,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(then_branch, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9244,"byte_end":9248,"line_start":269,"line_end":269,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(else_stmt, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9547,"byte_end":9551,"line_start":279,"line_end":279,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(init_stmt, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9639,"byte_end":9643,"line_start":281,"line_end":281,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(condition, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9769,"byte_end":9773,"line_start":283,"line_end":283,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(update_stmt, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":9863,"byte_end":9867,"line_start":285,"line_end":285,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(body, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10075,"byte_end":10079,"line_start":292,"line_end":292,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(expression, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10190,"byte_end":10194,"line_start":294,"line_end":294,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(&case.value, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10270,"byte_end":10274,"line_start":295,"line_end":295,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(&case.body, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10421,"byte_end":10425,"line_start":298,"line_end":298,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(default_stmt, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10634,"byte_end":10638,"line_start":303,"line_end":303,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.visit_node_recursive(arg, visitor, depth + 1);","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/semantic.rs","byte_start":10789,"byte_end":10793,"line_start":307,"line_end":307,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.visit_node_recursive(value, visitor, depth + 1);","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: parameter is only used in recursion\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/semantic.rs:246:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m246\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn visit_node_recursive<F>(&self, node: &AstNode, visitor: &mut F, depth: u32)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: parameter used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/semantic.rs:255:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(stmt, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m259\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(body, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(condition, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(then_branch, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Some(else_stmt) = else_branch {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(else_stmt, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m279\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(init_stmt, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m280\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(condition, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Some(update_stmt) = update {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(update_stmt, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(body, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(expression, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                for case in cases {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(&case.value, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(&case.body, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(default_stmt, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.visit_node_recursive(arg, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                self.visit_node_recursive(value, visitor, depth + 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 9 previous errors\u001b[0m\n\n"}
